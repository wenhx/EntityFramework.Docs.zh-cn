---
title: 排序规则和区分大小写-EF Core
description: 如何在数据库和查询中配置排序规则和区分大小写
author: roji
ms.date: 04/27/2020
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/collations-and-case-sensitivity.md
ms.openlocfilehash: 1c9344b8e96142645f55e8d830dfd350dc10aa96
ms.sourcegitcommit: 92d54fe3702e0c92e198334da22bacb42e9842b1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/10/2020
ms.locfileid: "84666179"
---
# <a name="collations-and-case-sensitivity"></a><span data-ttu-id="9ddd8-103">排序规则和区分大小写</span><span class="sxs-lookup"><span data-stu-id="9ddd8-103">Collations and Case Sensitivity</span></span>

> [!NOTE]
> <span data-ttu-id="9ddd8-104">EF Core 5.0 中已引入了此功能。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-104">This feature is introduced in EF Core 5.0.</span></span>

<span data-ttu-id="9ddd8-105">数据库中的文本处理可能会很复杂，并且需要更多用户注意。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-105">Text processing in databases can be a complex, and requires more user attention that one would suspect.</span></span> <span data-ttu-id="9ddd8-106">一方面，数据库处理文本的方式有很大差别;例如，尽管某些数据库默认区分大小写（例如 Sqlite、PostgreSQL），但其他数据库不区分大小写（SQL Server、MySQL）。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-106">For one thing, databases vary considerably in how they handle text; for example, while some databases are case-sensitive by default (e.g. Sqlite, PostgreSQL), others are case-insensitive (SQL Server, MySQL).</span></span> <span data-ttu-id="9ddd8-107">此外，由于索引使用情况，区分大小写和类似方面可能会对查询性能产生很大的影响：尽管在区分大小写的 `string.Lower` 数据库中使用强制不区分大小写的比较可能会很有吸引力，但这样做可能会阻止应用程序使用索引。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-107">In addition, because of index usage, case-sensitivity and similar aspects can have a far-reaching impact on query performance: while it may be tempting to use `string.Lower` to force a case-insensitive comparison in a case-sensitive database, doing so may prevent your application from using indexes.</span></span> <span data-ttu-id="9ddd8-108">本页详细说明了如何配置区分大小写或更一般的排序规则，以及如何在不影响查询性能的情况下有效地执行此操作。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-108">This page details how to configure case sensitivity, or more generally, collations, and how to do so in an efficient way without compromising query performance.</span></span>

## <a name="introduction-to-collations"></a><span data-ttu-id="9ddd8-109">排序规则简介</span><span class="sxs-lookup"><span data-stu-id="9ddd8-109">Introduction to collations</span></span>

<span data-ttu-id="9ddd8-110">文本处理中的基本概念是*排序规则*，这是一组规则，用于确定文本值如何排序和比较是否相等。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-110">A fundamental concept in text processing is the *collation*, which is a set of rules determining how text values are ordered and compared for equality.</span></span> <span data-ttu-id="9ddd8-111">例如，虽然不区分大小写的排序规则不会在大写字母和小写字母之间忽略差异，所以区分大小写的排序规则不会。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-111">For example, while a case-insensitive collation disregards differences between upper- and lower-case letters for the purposes of equality comparison, a case-sensitive collation does not.</span></span> <span data-ttu-id="9ddd8-112">但是，因为区分大小写是区分区域性的（例如 `i` ， `I` 表示土耳其语中的不同字母），所以存在多个不区分大小写的排序规则，每个排序规则都有自己的一组规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-112">However, since case-sensitivity is culture-sensitive (e.g. `i` and `I` represent different letter in Turkish), there exist multiple case-insensitive collations, each with its own set of rules.</span></span> <span data-ttu-id="9ddd8-113">排序规则的范围还超出了区分大小写的字符数据的其他方面;例如，在德语中，有时（但并非总是）需要将 `ä` 和视为 `ae` 相同。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-113">The scope of collations also extends beyond case-sensitivity, to other aspects of character data; in German, for example, it is sometimes (but not always) desirable to treat `ä` and `ae` as identical.</span></span> <span data-ttu-id="9ddd8-114">最后，排序规则还定义文本值的*排序*方式：德语位置 `ä` 之后 `a` ，瑞典语会将其置于字母表的末尾。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-114">Finally, collations also define how text values are *ordered*: while German places `ä` after `a`, Swedish places it at the end of the alphabet.</span></span>

<span data-ttu-id="9ddd8-115">数据库中的所有文本操作都使用排序规则，无论是显式还是隐式地确定操作比较和排序字符串的方式。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-115">All text operations in a database use a collation - whether explicitly or implicitly - to determine how the operation compares and orders strings.</span></span> <span data-ttu-id="9ddd8-116">可用排序规则及其命名方案的实际列表是特定于数据库的;请参阅[以下部分](#database-specific-information)，了解各种数据库相关文档页的链接。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-116">The actual list of available collations and their naming schemes is database-specific; consult [the section below](#database-specific-information) for links to relevant documentation pages of various databases.</span></span> <span data-ttu-id="9ddd8-117">幸运的是，数据库通常允许在数据库级或列级定义默认排序规则，并显式指定哪个排序规则应该用于查询中的特定操作。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-117">Fortunately, database do generally allow a default collation to be defined at the database or column level, and to explicitly specify which collation should be use for specific operations in a query.</span></span>

## <a name="database-collation"></a><span data-ttu-id="9ddd8-118">数据库排序规则</span><span class="sxs-lookup"><span data-stu-id="9ddd8-118">Database collation</span></span>

<span data-ttu-id="9ddd8-119">在大多数数据库系统中，默认排序规则是在数据库级别定义的;除非重写，否则该排序规则将隐式应用于该数据库中发生的所有文本操作。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-119">In most database systems, a default collation is defined at the database level; unless overridden, that collation implicitly applies to all text operations occurring within that database.</span></span> <span data-ttu-id="9ddd8-120">通常，数据库排序规则是在创建数据库时（通过 `CREATE DATABASE` DDL 语句）设置的，如果未指定，则默认为在安装时确定的某个服务器级别值。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-120">The database collation is typically set at database creation time (via the `CREATE DATABASE` DDL statement), and if not specified, defaults to a some server-level value determined at setup time.</span></span> <span data-ttu-id="9ddd8-121">例如，SQL Server 中的默认服务器级排序规则是 `SQL_Latin1_General_CP1_CI_AS` ，这是不区分大小写且区分重音的排序规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-121">For example, the default server-level collation in SQL Server is `SQL_Latin1_General_CP1_CI_AS`, which is a case-insensitive, accent-sensitive collation.</span></span> <span data-ttu-id="9ddd8-122">尽管数据库系统通常允许更改现有数据库的排序规则，但这样做可能会导致复杂;建议在创建数据库之前选择排序规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-122">Although database systems usually do permit altering the collation of an existing database, doing so can lead to complications; it is recommended to pick a collation before database creation.</span></span>

<span data-ttu-id="9ddd8-123">使用 EF Core 迁移来管理数据库架构时，模型的方法中的以下 `OnModelCreating` 内容将 SQL Server 数据库配置为使用区分大小写的排序规则：</span><span class="sxs-lookup"><span data-stu-id="9ddd8-123">When using EF Core migrations to manage your database schema, the following in your model's `OnModelCreating` method configures a SQL Server database to use a case-sensitive collation:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?range=40)]

## <a name="column-collation"></a><span data-ttu-id="9ddd8-124">列排序规则</span><span class="sxs-lookup"><span data-stu-id="9ddd8-124">Column collation</span></span>

<span data-ttu-id="9ddd8-125">也可以在文本列上定义排序规则，以覆盖数据库默认值。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-125">Collations can also be defined on text columns, overriding the database default.</span></span> <span data-ttu-id="9ddd8-126">如果某些列需要区分大小写，而数据库的其余部分需要区分大小写，则这会很有用。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-126">This can be useful if certain columns need to be case-insensitive, while the rest of the database needs to be case-sensitive.</span></span>

<span data-ttu-id="9ddd8-127">使用 EF Core 迁移来管理数据库架构时，以下内容将属性的列配置为在其他情况下被配置为区分大小写的 `Name` 数据库中的不区分大小写：</span><span class="sxs-lookup"><span data-stu-id="9ddd8-127">When using EF Core migrations to manage your database schema, the following configures the column for the `Name` property to be case-insensitive in a database that is otherwise configured to be case-sensitive:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?name=OnModelCreating&highlight=6)]

## <a name="explicit-collation-in-a-query"></a><span data-ttu-id="9ddd8-128">查询中的显式排序规则</span><span class="sxs-lookup"><span data-stu-id="9ddd8-128">Explicit collation in a query</span></span>

<span data-ttu-id="9ddd8-129">在某些情况下，需要通过不同的查询使用不同的排序规则查询同一列。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-129">In some cases, the same column needs to be queried using different collations by different queries.</span></span> <span data-ttu-id="9ddd8-130">例如，一个查询可能需要对列执行区分大小写的比较，而另一个查询可能需要对同一列执行不区分大小写的比较。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-130">For example, one query may need to perform a case-sensitive comparison on a column, while another may need to perform a case-insensitive comparison on the same column.</span></span> <span data-ttu-id="9ddd8-131">这可以通过在查询本身中显式指定排序规则来实现：</span><span class="sxs-lookup"><span data-stu-id="9ddd8-131">This can be accomplished by explicitly specifying a collation within the query itself:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?name=SimpleQueryCollation)]

<span data-ttu-id="9ddd8-132">这会 `COLLATE` 在 SQL 查询中生成一个子句，该子句将应用区分大小写的排序规则，而不考虑在列或数据库级别定义的排序规则：</span><span class="sxs-lookup"><span data-stu-id="9ddd8-132">This generates a `COLLATE` clause in the SQL query, which applies a case-sensitive collation regardless of the collation defined at the column or database level:</span></span>

```sql
SELECT [c].[Id], [c].[Name]
FROM [Customers] AS [c]
WHERE [c].[Name] COLLATE SQL_Latin1_General_CP1_CS_AS = N'John'
```

### <a name="explicit-collations-and-indexes"></a><span data-ttu-id="9ddd8-133">显式排序规则和索引</span><span class="sxs-lookup"><span data-stu-id="9ddd8-133">Explicit collations and indexes</span></span>

<span data-ttu-id="9ddd8-134">索引是数据库性能最重要的因素之一-使用索引高效运行的查询可以网格不使用该索引的停止。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-134">Indexes are one of the most important factors in database performance - a query that runs efficiently with an index can grind to a halt without that index.</span></span> <span data-ttu-id="9ddd8-135">索引隐式继承列的排序规则;这意味着，对列的所有查询都将自动符合使用该列定义的索引的条件，前提是该查询不指定其他排序规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-135">Indexes implicitly inherit the collation of their column; this means that all queries on the column are automatically eligible to use indexes defined on that column - provided that the query doesn't specify a different collation.</span></span> <span data-ttu-id="9ddd8-136">在查询中指定显式排序规则通常会阻止该查询使用该列上定义的索引，因为排序规则将不再匹配;因此，建议在使用此功能时务必小心。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-136">Specifying an explicit collation in a query will generally prevent that query from using an index defined on that column, since the collations would no longer match; it is therefore recommended to exercise caution when using this feature.</span></span> <span data-ttu-id="9ddd8-137">始终最好在列（或数据库）级别定义排序规则，以允许所有查询隐式使用该排序规则并使任何索引受益。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-137">It is always preferable to define the collation at the column (or database) level, allowing all queries to implicitly use that collation and benefit from any index.</span></span>

<span data-ttu-id="9ddd8-138">请注意，某些数据库允许在创建索引时（例如 PostgreSQL、Sqlite）定义排序规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-138">Note that some databases allow the collation to be defined when creating an index (e.g. PostgreSQL, Sqlite).</span></span> <span data-ttu-id="9ddd8-139">这允许在同一列中定义多个索引，并通过不同的排序规则（例如，区分大小写和不区分大小写的比较）加速操作。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-139">This allows multiple indexes to be defined on the same column, speeding up operations with different collations (e.g. both case-sensitive and case-insensitive comparisons).</span></span> <span data-ttu-id="9ddd8-140">有关更多详细信息，请参阅数据库提供程序的文档。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-140">Consult your database provider's documentation for more details.</span></span>

> [!WARNING]
> <span data-ttu-id="9ddd8-141">请始终检查查询的查询计划，并确保在对大量数据执行的性能关键查询中使用正确的索引。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-141">Always inspect the query plans of your queries, and make sure the proper indexes are being used in performance-critical queries executing over large amounts of data.</span></span> <span data-ttu-id="9ddd8-142">通过（或通过调用）在查询中替代区分大小写 `EF.Functions.Collate` `string.ToLower` 会对应用程序的性能产生很大的影响。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-142">Overriding case-sensitivity in a query via `EF.Functions.Collate` (or by calling `string.ToLower`) can have a very significant impact on your application's performance.</span></span>

## <a name="translation-of-built-in-net-string-operations"></a><span data-ttu-id="9ddd8-143">内置 .NET 字符串操作的翻译</span><span class="sxs-lookup"><span data-stu-id="9ddd8-143">Translation of built-in .NET string operations</span></span>

<span data-ttu-id="9ddd8-144">在 .NET 中，string 相等性默认情况下区分大小写： `s1 == s2` 执行要求字符串相同的序号比较。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-144">In .NET, string equality is case-sensitive by default: `s1 == s2` performs an ordinal comparison that requires the strings to be identical.</span></span> <span data-ttu-id="9ddd8-145">因为数据库的默认排序规则会变化，并且因为需要简单的相等性来使用索引，所以 EF Core 不会尝试将简单的相等转换为区分大小写的数据库操作： c # 相等性会直接转换为 SQL 相等性，这可能会也可能不区分大小写，具体取决于所使用的特定数据库及其排序规则配置。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-145">Because the default collation of databases varies, and because it is desirable for simple equality to use indexes, EF Core makes no attempt to translate simple equality to a database case-sensitive operation: C# equality is translated directly to SQL equality, which may or may not be case-sensitive, depending on the specific database in use and its collation configuration.</span></span>

<span data-ttu-id="9ddd8-146">此外，.NET 还提供了 [`string.Equals`](https://docs.microsoft.com/dotnet/api/system.string.equals#System_String_Equals_System_String_System_StringComparison_) 接受枚举的重载 [`StringComparison`](https://docs.microsoft.com/dotnet/api/system.stringcomparison) ，这允许为比较指定区分大小写和文化。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-146">In addition, .NET provides overloads of [`string.Equals`](https://docs.microsoft.com/dotnet/api/system.string.equals#System_String_Equals_System_String_System_StringComparison_) accepting a [`StringComparison`](https://docs.microsoft.com/dotnet/api/system.stringcomparison) enum, which allows specifying case-sensitivity and culture for the comparison.</span></span> <span data-ttu-id="9ddd8-147">按照设计，EF Core refrains 将这些重载转换为 SQL，尝试使用它们将导致异常。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-147">By design, EF Core refrains from translating these overloads to SQL, and attempting to use them will result in an exception.</span></span> <span data-ttu-id="9ddd8-148">一方面，EF Core 知道不应使用不区分大小写的排序规则或不区分大小写的排序规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-148">For one thing, EF Core does know not which case-sensitive or case-insensitive collation should be used.</span></span> <span data-ttu-id="9ddd8-149">更重要的是，在大多数情况下，应用排序规则会阻止索引的使用，对非常基本的常用 .NET 构造的性能产生显著影响。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-149">More importantly, applying a collation would in most cases prevent index usage, significantly impacting performance for a very basic and commonly-used .NET construct.</span></span> <span data-ttu-id="9ddd8-150">若要强制查询使用区分大小写或不区分大小写的比较，请通过 `EF.Functions.Collate` [上面详细](#explicit-collations-and-indexes)说明显式指定排序规则。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-150">To force a query to use case-sensitive or case-insensitive comparison, specify a collation explicitly via `EF.Functions.Collate` as [detailed above](#explicit-collations-and-indexes).</span></span>

## <a name="database-specific-information"></a><span data-ttu-id="9ddd8-151">数据库特定的信息</span><span class="sxs-lookup"><span data-stu-id="9ddd8-151">Database-specific information</span></span>

* <span data-ttu-id="9ddd8-152">[SQL Server 有关排序规则的文档](https://docs.microsoft.com/sql/relational-databases/collations/collation-and-unicode-support)。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-152">[SQL Server documentation on collations](https://docs.microsoft.com/sql/relational-databases/collations/collation-and-unicode-support).</span></span>
* <span data-ttu-id="9ddd8-153">[有关排序规则的数据表](https://docs.microsoft.com/dotnet/standard/data/sqlite/collation)。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-153">[Microsoft.Data.Sqlite documentation on collations](https://docs.microsoft.com/dotnet/standard/data/sqlite/collation).</span></span>
* <span data-ttu-id="9ddd8-154">[有关排序规则的 PostgreSQL 文档](https://www.postgresql.org/docs/current/collation.html)。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-154">[PostgreSQL documentation on collations](https://www.postgresql.org/docs/current/collation.html).</span></span>
* <span data-ttu-id="9ddd8-155">[有关排序规则的 MySQL 文档](https://dev.mysql.com/doc/refman/en/charset-general.html)。</span><span class="sxs-lookup"><span data-stu-id="9ddd8-155">[MySQL documentation on collations](https://dev.mysql.com/doc/refman/en/charset-general.html).</span></span>
